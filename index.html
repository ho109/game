<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>í„´ì œì „íˆ¬ ê²Œì„?(ì»¤ìŠ¤í…€)</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; color: white; }
    canvas { display: block; margin: 0 auto; background: #222; border: 3px solid white; }
  </style>
  <!-- âœ… favicon 404 ë°©ì§€ -->
  <link rel="icon" href="data:;base64,=">
</head>
<body>
<canvas id="gameCanvas" width="500" height="550"></canvas>
<script>
  // âœ… ìº”ë²„ìŠ¤ ë° ê²Œì„ ì´ˆê¸° ì„¤ì •
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const fightBox = { x: 50, y: 180, width: 400, height: 200 };
const player = {
  x: 240, y: 340, width: 20, height: 20, speed: 4,
  hp: 35, maxHp: 35, color: "lime", items: 0
};

const text = {
  helpToggle: {
    ko: "â“ ë„ì›€ë§ ë³´ê¸° (Z / X / C)",
    en: "â“ Show Help (Z / X / C)"
  },
  helpLines: {
    ko: ["- Z: ê³µê²© ê²Œì´ì§€ ì‹œì‘", "- X: ì•„ì´í…œ ì‚¬ìš©", "- C: í•„ì‚´ê¸° / ìƒì  ë‚˜ê°€ê¸°"],
    en: ["- Z: Start Attack Gauge", "- X: Use Item", "- C: Special / Exit Shop"]
  },
  restartPrompt: {
    ko: "ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘",
    en: "Press Space to Restart"
  },
  victory: {
    ko: "Victory!",
    en: "Victory!"
  },
  gameOver: {
    ko: "Game Over",
    en: "Game Over"
  },
  shopTitle: {
    ko: "ê³ ë¸”ë¦° ìƒì  ğŸª™",
    en: "Goblin Shop ğŸª™"
  },
  shopItems: {
    ko: ["ì•„ì´í…œ (10g)", "ë¬´ê¸°   (10g)"],
    en: ["Item (10g)", "Weapon (10g)"]
  },
  shopInstruction: {
    ko: "Z: êµ¬ë§¤ | C: ë‚˜ê°€ê¸°",
    en: "Z: Buy | C: Exit"
  },
  shopCoins: {
    ko: "ë³´ìœ  ì½”ì¸: ",
    en: "Coins: "
  },
  itemsLabel: {
    ko: "ì•„ì´í…œ: ",
    en: "Items: "
  },
  langLabel: {
    ko: "ğŸ‡°ğŸ‡· í•œêµ­ì–´",
    en: "ğŸ‡ºğŸ‡¸ English"
  }
}; // (ê¸°ì¡´ ë‹¤êµ­ì–´ í…ìŠ¤íŠ¸ ê°ì²´ ê·¸ëŒ€ë¡œ ìœ ì§€)

let coins = 0;
let currentEnemyIndex = 0;
let enemy = null;
let tick = 0;
const bullets = [];
let gameOver = false;
let gameWon = false;
let turn = "player";
let attackTimer = 0;
let attackDuration = 300;
let isAttackGaugeActive = false;
let gaugeX = 0;
let gaugeDir = 4;
let isGameRunning = false;
let keys = {};
let isInShop = false;
let shopSelection = 0;
let playerAttackPower = 1;
let robotWarnings = []; // ê²½ê³  íƒ€ì¼ë“¤
let robotWarnTimer = 0;
let showHelp = false;
let language = "ko";
let animationFrameId = null; // ë£¨í”„ ì¶”ì ìš©
let screenShake = 0;
let flashTimer = 0;
let difficulty = "normal";
let difficultyMenuActive = true;
let difficultyOptions = ["easy", "normal", "hard"];
let selectedDifficultyIndex = 1;
let cheatUnlocked = false;

const imagePaths = [
  "image/slime.png",        // 0
  "image/bat.png",          // 1
  "image/skel.png",         // 2
  "image/skull.png",        // 3
  "image/king_slime.png",   // 4
  "image/gob_shop.png",     // âœ… ê³ ë¸”ë¦° ìƒì  1
  "image/robot.png",        // 6
  "image/weezered.png",     // 7
  "image/real_wizard.png",  // 8
  "image/gob_shop.png",     // âœ… ê³ ë¸”ë¦° ìƒì  2
  "image/fire.png"          // 10
];

const enemies = [
  { nameKo: "ìŠ¬ë¼ì„", nameEn: "Slime", maxHp: 10, atk: 1, coin: 2, pattern: () => spawnSlimeCornerSplits(), img: new Image() },
  { nameKo: "ë°•ì¥", nameEn: "Bat", maxHp: 12, atk: 2, coin: 3, pattern: () => spawnSideBullets(3), img: new Image() },
  { nameKo: "í•´ê³¨ ê¶ìˆ˜", nameEn: "Skeleton Archer", maxHp: 15, atk: 3, coin: 5, pattern: () => spawnDiagonalBulletsFromTopRight(), img: new Image() },
  { nameKo: "í•´ê³¨ ë¨¸ë¦¬", nameEn: "Skull", maxHp: 18, atk: 3, coin: 5, pattern: () => spawnRandomBullets(6), img: new Image() },
  { nameKo: "ê±°ëŒ€ ìŠ¬ë¼ì„", nameEn: "King Slime", maxHp: 80, atk: 2, coin: 7, pattern: () => spawnBouncingBullets(), scale: 2, img: new Image() },
  { nameKo: "ê³ ë¸”ë¦° ìƒì ", nameEn: "Goblin Shop", maxHp: 9999, atk: 0, coin: 0, pattern: () => {}, img: new Image() },
  { nameKo: "ë¡œë´‡", nameEn: "Robot", maxHp: 30, atk: 3, coin: 8, pattern: () => spawnModifiedRobotBullets(), img: new Image() },
  { nameKo: "ë§ˆë²•ì‚¬..?", nameEn: "Wizard..?", maxHp: 25, atk: 2, coin: 0, pattern: () => spawnSpiralBullets(), img: new Image() },
  { nameKo: "ì§„ì§œ ë§ˆë²•ì‚¬", nameEn: "Real Wizard", maxHp: 40, atk: 3, coin: 15, pattern: () => realWizardPattern(), img: new Image() },
  { nameKo: "ê³ ë¸”ë¦° ìƒì ", nameEn: "Goblin Shop", maxHp: 9999, atk: 0, coin: 0, pattern: () => {}, img: new Image() },
  { nameKo: "ë¶ˆ", nameEn: "Fire", maxHp: 35, atk: 5, coin: 20, pattern: () => spawnRisingBullets(), img: new Image() }
];

imagePaths.forEach((path, index) => {
  const img = new Image();
  img.src = path;
  img.onload = () => {
    enemies[index].img = img;

    // ë§ˆì§€ë§‰ ì´ë¯¸ì§€ ë¡œë”© ì™„ë£Œ í›„ ì  ì„¤ì •
    if (index === imagePaths.length - 1) {
      enemy = enemies[currentEnemyIndex];
      // âœ… ë£¨í”„ ì‹œì‘ì€ ë¬´ì¡°ê±´ updateë§Œ ëŒë¦¼
      if (animationFrameId === null) {
        animationFrameId = requestAnimationFrame(update);
      }
    }
  };
});

function applyDifficultyStats(enemy) {
  let factor = 1;
  if (difficulty === "easy") factor = 0.8;
  if (difficulty === "hard") factor = 1.3;

  enemy.hp = Math.round(enemy.maxHp * factor);
  enemy.atk = Math.round(enemy.atk * factor);
}

function resetPlayerStats() {
  const baseMax = 35;
  player.maxHp = difficulty === "easy" ? baseMax + 5 : difficulty === "hard" ? baseMax - 5 : baseMax;
  player.hp = player.maxHp;
}

function detectCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

function drawDifficultyMenu() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.font = "20px Arial";
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.fillText(language === "ko" ? "ë‚œì´ë„ ì„ íƒ" : "Select Difficulty", canvas.width / 2, 80);

  const howTo = language === "ko"
    ? ["ì´ë™: í™”ì‚´í‘œ ë˜ëŠ” WASD", "Z: ê³µê²©", "X: ì•„ì´í…œ ì‚¬ìš© (ìˆì„ ê²½ìš°ì—ë§Œ)", "C: íŠ¹ìˆ˜ê³µê²©"]
    : ["Move: Arrow keys or WASD", "Z: Attack", "X: Item", "C: Special / Shop"];

  ctx.font = "16px Arial"; //í°íŠ¸ í¬ê¸°ì„
  howTo.forEach((line, i) => {
    ctx.fillText(line, canvas.width / 2, 120 + i * 24); //í°íŠ¸ ê°„ê²©ì„
  });

  // ì—”í„° ì•ˆë‚´ ì¶”ê°€
  ctx.font = "14px Arial";
  ctx.fillText(language === "ko" ? "ì—”í„°ë¥¼ ëˆŒëŸ¬ ì‹œì‘" : "Press Enter to Start", canvas.width / 2, 450);
  
  // ì–¸ì–´ ì „í™˜ ë²„íŠ¼
  ctx.fillStyle = "white";
  ctx.fillRect(canvas.width - 90, canvas.height - 50, 70, 30);
  ctx.fillStyle = "black";
  ctx.fillText(language === "ko" ? "ğŸ‡°ğŸ‡· í•œêµ­ì–´" : "ğŸ‡ºğŸ‡¸ English", canvas.width - 55, canvas.height - 30);

  const labels = {
    easy:   { ko: "ì‰¬ì›€", en: "Easy" },
    normal: { ko: "ë³´í†µ", en: "Normal" },
    hard:   { ko: "ì–´ë ¤ì›€", en: "Hard" }
  };

  difficultyOptions.forEach((key, idx) => {
    const isSelected = idx === selectedDifficultyIndex;
    ctx.fillStyle = isSelected ? "lime" : "white";
    ctx.strokeStyle = "white";
    ctx.fillRect(150, 230 + idx * 60, 200, 40);
    ctx.strokeRect(150, 230 + idx * 60, 200, 40);
    ctx.fillStyle = "black";
    ctx.fillText(labels[key][language], canvas.width / 2, 260 + idx * 60);
  });
}

function drawAttackGauge() {
  if (!isAttackGaugeActive) return;
  const barX = canvas.width / 2 - 150;
  const barY = 470;
  ctx.fillStyle = "white";
  ctx.fillRect(barX, barY, 300, 20);
  ctx.fillStyle = "gray";
  ctx.fillRect(barX + 145, barY, 10, 20); // ì¤‘ì•™ ë…¸ë€ ëª©í‘œ ì§€ì 
  ctx.fillStyle = "red";
  ctx.fillRect(barX + gaugeX, barY, 10, 20); // ì›€ì§ì´ëŠ” ê²Œì´ì§€ ë°”
  gaugeX += gaugeDir;
  if (gaugeX <= 0 || gaugeX >= 290) gaugeDir *= -1;
}


function drawHealthBar(x, y, width, height, current, max, color) {
  ctx.fillStyle = "gray";
  ctx.fillRect(x, y, width, height);
  const ratio = Math.max(0, current / max);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, width * ratio, height);
}

function startGameLoop() {
  isGameRunning = true; // âœ… ì´ ë¶€ë¶„ì€ í•­ìƒ ì„¤ì •ë˜ë„ë¡
  if (animationFrameId === null) {
    animationFrameId = requestAnimationFrame(update);
  }
}

function update() {
  if (!isGameRunning && difficultyMenuActive) {
    drawDifficultyMenu();
    animationFrameId = requestAnimationFrame(update);
    return;
  }

  if (!isGameRunning) return;
  
  tick++;

  // ğŸ’¥ í”Œë˜ì‹œ ì´í™íŠ¸
  if (flashTimer > 0) {
    canvas.style.backgroundColor = (flashTimer % 2 === 0) ? "darkred" : "black";
    flashTimer--;
  } else {
    canvas.style.backgroundColor = "black";
  }

  // ğŸ’¥ í™”ë©´ í”ë“¤ë¦¼ ì ìš©
  if (screenShake > 0) {
    const dx = (Math.random() - 0.5) * 10;
    const dy = (Math.random() - 0.5) * 10;
    ctx.save();
    ctx.translate(dx, dy);
    screenShake--;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawUI();
  drawAttackGauge();
  drawBullets();
  updatePlayerMovement();

  // âœ… ë¡œë´‡ ê²½ê³  í›„ í­ë°œí˜• íƒ„ë§‰
  if (robotWarnings.length > 0) {
    robotWarnTimer--;
    if (robotWarnTimer <= 0) {
      robotWarnings.forEach(pos => {
        const cx = pos.x;
        const cy = pos.y;
        const count = 8;
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count;
          bullets.push({
            x: cx,
            y: cy,
            width: 8,
            height: 8,
            speedX: Math.cos(angle) * 2.5,
            speedY: Math.sin(angle) * 2.5
          });
        }
      });
      screenShake = 6;
      flashTimer = 5;
      robotWarnings = [];
    }
  }

  if (!gameOver && turn === "enemy") {
    enemy.pattern();
    updateBullets();
    attackTimer--;
    if (attackTimer <= 0) {
      turn = "player";
      bullets.length = 0;
    }
  }

  // ğŸ’¥ í”ë“¤ë¦¼ í•´ì œ
  if (screenShake > 0) {
    ctx.restore();
  }

  animationFrameId = requestAnimationFrame(update);
}

function spawnDiagonalBulletsFromTopRight() {
  if (tick % 25 !== 0) return; // ì†ë„ í”„ë ˆì„ ë†’ì´ê¸°
  const count = 5; // ì¤„ì–´ë“  ë°€ë„
  for (let i = 0; i < count; i++) {
    const startX = fightBox.x + fightBox.width;
    const startY = fightBox.y;
    const playerCenterX = player.x + player.width / 2;
    const playerCenterY = player.y + player.height / 2;
    const dx = playerCenterX - startX;
    const dy = playerCenterY - startY;
    const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.25; // ì†Œí­ ë¶„ì‚°
    const speed = 4 + Math.random() * 1.5; // ë” ë¹ ë¥´ê²Œ
    const velocityX = Math.cos(angle) * speed;
    const velocityY = Math.sin(angle) * speed;

    bullets.push({
      x: startX,
      y: startY,
      width: 10,
      height: 10,
      speedX: velocityX,
      speedY: velocityY
    });
  }
}           

function spawnModifiedRobotBullets() {
  if (tick % 90 !== 0 || robotWarnings.length > 0) return;

  robotWarnings = [];
  robotWarnTimer = 50 //

  for (let i = 0; i < 6; i++) { // âœ… ê²½ê³  ì§€ì  6ê°œ
    const x = fightBox.x + Math.random() * fightBox.width;
    const y = fightBox.y + Math.random() * fightBox.height;
    robotWarnings.push({ x, y });
  }
}


function spawnSpiralBullets() {
  if (tick % 30 !== 0) return;
  const angleCount = 12;
  const centerX = fightBox.x + fightBox.width / 2;
  const centerY = fightBox.y + fightBox.height / 2;
  for (let i = 0; i < angleCount; i++) {
    const angle = (tick / 10) + (i * (Math.PI * 2 / angleCount));
    bullets.push({
      x: centerX,
      y: centerY,
      width: 8,
      height: 8,
      speedX: Math.cos(angle) * 2,
      speedY: Math.sin(angle) * 2
    });
  }
}
function realWizardPattern() {
  if (enemy.patternIndex === undefined) enemy.patternIndex = 0;
  if (enemy.patternTimer === undefined) enemy.patternTimer = 0;

  const stage = enemy.patternIndex;
  const timer = enemy.patternTimer;

  if (timer === 0) bullets.length = 0;

  if (stage === 0) spawnMeteorExplosions();
  if (stage === 1) spawnHomingShotsTeleport();
  if (stage === 2) spawnInwardSpiral();
  if (stage === 3) spawnDelayedBlastCross();

  enemy.patternTimer++;

  if (enemy.patternTimer > 300) {
    enemy.patternIndex++;
    enemy.patternTimer = 0;

    if (enemy.patternIndex > 3) {
      enemy.patternIndex = 0;
      if (enemy.hp > 0) {
        enemy.hp = Math.min(enemy.maxHp, enemy.hp + Math.floor(enemy.maxHp / 3));
        flashTimer = 15;
        screenShake = 8;
      }
    }
  }
}

function spawnMeteorExplosions() {
  if (tick % 45 === 0) {
    const meteor = {
      x: fightBox.x + Math.random() * (fightBox.width - 30),
      y: fightBox.y - 30,
      width: 30,
      height: 30,
      speedY: 2.5,
      starburst: true,
      timer: 40,
      blink: 0
    };
    bullets.push(meteor);
  }
}

function spawnHomingShotsTeleport() {
  if (tick % 60 !== 0) return;

  const burstCount = 3; // ë™ì‹œ ë°œì‚¬ ìˆ˜
  for (let i = 0; i < burstCount; i++) {
    const fromX = fightBox.x + Math.random() * fightBox.width;
    const fromY = fightBox.y + Math.random() * fightBox.height;

    const dx = (player.x + player.width / 2) - fromX;
    const dy = (player.y + player.height / 2) - fromY;
    const angle = Math.atan2(dy, dx);
    const speed = 2 + Math.random() * 1.5;

    bullets.push({
      x: fromX,
      y: fromY,
      width: 10,
      height: 10,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed
    });
  }

  screenShake = 2;
  flashTimer = 4;
}


function spawnInwardSpiral() {
  if (tick % 10 !== 0) return;

  const centerX = fightBox.x + fightBox.width / 2;
  const centerY = fightBox.y + fightBox.height / 2;

  const radius = 200;
  const count = 12;

  for (let i = 0; i < count; i++) {
    const angle = (tick / 20) + (Math.PI * 2 * i / count);
    bullets.push({
      x: centerX + Math.cos(angle) * radius,
      y: centerY + Math.sin(angle) * radius,
      width: 6,
      height: 6,
      speedX: -Math.cos(angle) * 1.5,
      speedY: -Math.sin(angle) * 1.5
    });
  }
}

function spawnDelayedBlastCross() {
  if (tick % 80 !== 0) return;

  const dropCount = 5;
  for (let i = 0; i < dropCount; i++) {
    const offsetX = Math.random() * fightBox.width;
    const startX = fightBox.x + offsetX;
    const startY = fightBox.y - 20 - Math.random() * 40; // ìœ„ìª½ + ì•½ê°„ ìœ„ì—ì„œ ì‹œì‘
    const delay = 50 + Math.random() * 30; // ê°ì í­ë°œ ë”œë ˆì´ ë‹¤ë¦„

    bullets.push({
      x: startX,
      y: startY,
      width: 14,
      height: 14,
      speedY: 1.8,
      delayBlast: true,
      timer: delay,
      blink: 0
    });
  }
}


function spawnSideBullets(count = 2) {
  if (tick % 20 !== 0) return; // ë°œì‚¬ ì‹œê°„ ì¡°ì •ì •
  for (let i = 0; i < count; i++) {
    bullets.push({
      x: i % 2 === 0 ? fightBox.x : fightBox.x + fightBox.width,
      y: fightBox.y + Math.random() * fightBox.height,
      width: 10,
      height: 10,
      speedX: i % 2 === 0 ? 2 : -2,
      horizontal: true
    });
  }
}

function spawnRandomBullets(count = 4) {
  if (tick % 24 !== 0) return; // ì•½ 0.4ì´ˆ ê°„ê²©
  for (let i = 0; i < count; i++) {
    let x = fightBox.x + Math.random() * fightBox.width;
    x += (Math.random() - 0.5) * 60; // ì¢Œìš° Â±30px í¼ì§
    x = Math.max(fightBox.x, Math.min(fightBox.x + fightBox.width - 10, x)); // ê²½ê³„ ì œí•œ

    bullets.push({
      x,
      y: fightBox.y,
      width: 10,
      height: 10,
      speedY: 2.5 + Math.random() * 1.5
    });
  }
}

function spawnBouncingBullets() {
  if (tick % 30 !== 0) return;
  const count = 10; // 10
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1.2 + Math.random() * 0.8; // ì‚´ì§ ëŠë¦¬ê²Œ ì¡°ì •
    bullets.push({
      x: fightBox.x + fightBox.width / 2 + (Math.random() * 40 - 20),
      y: fightBox.y + fightBox.height / 2 + (Math.random() * 40 - 20),
      width: 6,
      height: 6,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed,
      bounce: true,
      bouncesLeft: 2 // íŠ•ê¹€ íšŸìˆ˜ë„ 3 â†’ 2 ë¡œ ë‚®ì¶œ ìˆ˜ ìˆìŒ
    });
  }
}

function spawnRisingBullets() {
  if (tick % 20 !== 0) return;

  const spawnCount = Math.random() < 0.5 ? 1 : 2;
  for (let i = 0; i < spawnCount; i++) {
    bullets.push({
      x: fightBox.x + Math.random() * fightBox.width,
      y: fightBox.y + fightBox.height + Math.random() * 20,
      width: 10,
      height: 10,
      speedY: -1.43, // ğŸ”¼ 10% ìƒìŠ¹
      fireExplode: true,
      flicker: true,
      baseX: Math.random() * Math.PI * 2
    });
  }
}

function spawnSlimeCornerSplits() {
  if (tick % 60 !== 0) return;
  const corners = [
    { x: fightBox.x, y: fightBox.y },
    { x: fightBox.x + fightBox.width, y: fightBox.y },
    { x: fightBox.x, y: fightBox.y + fightBox.height },
    { x: fightBox.x + fightBox.width, y: fightBox.y + fightBox.height },
  ];
  corners.forEach(corner => {
    bullets.push({
      x: corner.x,
      y: corner.y,
      width: 12,
      height: 12,
      speedX: (player.x - corner.x) / 60,
      speedY: (player.y - corner.y) / 60
    });
  });
}

function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];

    // ê¸°ë³¸ ì´ë™
    if (b.speedX) b.x += b.speedX;
    if (b.speedY) b.y += b.speedY;

    // ì¼ë ì„ íš¨ê³¼ (ë¶ˆê½ƒ)
    if (b.flicker) {
      b.x += Math.sin(tick / 5 + (b.baseY || b.baseX || 0)) * 0.5;
    }

    // ğŸ”¥ ë¶ˆ íŒ¨í„´ í­ë°œ
    if (b.fireExplode && b.y + b.height <= fightBox.y) {
      explodeFireBullet(b);
      bullets.splice(i, 1);
      continue;
    }

    // â˜„ï¸ ìœ ì„± í­ë°œí˜•
    if (b.starburst) {
      b.timer--;
      b.blink = (b.blink + 1) % 20;
      if (b.timer <= 0) {
        const cx = b.x + b.width / 2;
        const cy = b.y + b.height / 2;
        for (let j = 0; j < 12; j++) {
          const angle = (Math.PI * 2 * j) / 12;
          bullets.push({
            x: cx,
            y: cy,
            width: 8,
            height: 8,
            speedX: Math.cos(angle) * 2,
            speedY: Math.sin(angle) * 2
          });
        }
        screenShake = 5;
        flashTimer = 10;
        bullets.splice(i, 1);
        continue;
      }
    }

    // ğŸ’£ ì§€ì—° í­ë°œí˜• (ì‹­ìíƒ„)
    if (b.delayBlast) {
      b.timer--;
      b.blink = (b.blink + 1) % 20;
      if (b.timer <= 0) {
        const cx = b.x + b.width / 2;
        const cy = b.y + b.height / 2;
        const spread = [
          { dx: 0, dy: -3 },
          { dx: 0, dy: 3 },
          { dx: -3, dy: 0 },
          { dx: 3, dy: 0 }
        ];
        for (const dir of spread) {
          bullets.push({
            x: cx,
            y: cy,
            width: 8,
            height: 8,
            speedX: dir.dx,
            speedY: dir.dy
          });
        }
        screenShake = 4;
        flashTimer = 8;
        bullets.splice(i, 1);
        continue;
      }
    }

    // ğŸ’¥ í”Œë ˆì´ì–´ í”¼ê²©
    if (!b.starburst && !b.delayBlast && detectCollision(player, b)) {
      b.y = -100;
      player.hp -= enemy.atk;
      if (player.hp <= 0) {
        gameOver = true;
        gameWon = false;
      }
    }
  }
}


function explodeFireBullet(bullet) {
  const centerX = bullet.x + bullet.width / 2;
  const centerY = bullet.y + bullet.height / 2;
  const angleCount = 7;
  for (let i = 0; i < angleCount; i++) {
    const angle = (Math.PI * 2 / angleCount) * i;
    const speed = 2 + Math.random() * 0.5;
    bullets.push({
      x: centerX,
      y: centerY,
      width: 8,
      height: 8,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed
    });
  }
  flashTimer = 5;
  screenShake = 2;
}

function evaluateAttack() {
  const center = 150;
  const dist = Math.abs(gaugeX - center);
  let damage = 1;
  if (dist < 10) damage = 5;
  else if (dist < 30) damage = 3;
  else if (dist < 60) damage = 2;

  enemy.hp -= damage * playerAttackPower;
  if (enemy.hp <= 0) {
    coins += enemy.coin || 0;
    currentEnemyIndex++;
    if (currentEnemyIndex >= enemies.length) {
      gameOver = true;
      gameWon = true;
      return;
    } else {
      enemy = enemies[currentEnemyIndex];
      enemy.hp = enemy.maxHp;
      player.hp = player.maxHp;
      if (enemy.nameKo.includes("ê³ ë¸”ë¦°") || enemy.nameEn.includes("Goblin")); { 
        isInShop = true;
      }
    }
  }
  isAttackGaugeActive = false;
  turn = "enemy";
  attackTimer = attackDuration;
  bullets.length = 0;
}
    
function drawRobotWarnings() {
  ctx.fillStyle = "rgba(255, 100, 100, 0.5)"; // ì—°í•œ ë¹¨ê°• (50% íˆ¬ëª…ë„)
  robotWarnings.forEach(pos => {
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawBullets() {
  bullets.forEach(b => {
    if (b.starburst && b.blink < 10) return; // ê¹œë¹¡ì¼ ë•Œ ì•ˆ ê·¸ë¦¼
    ctx.fillStyle = b.starburst ? "yellow" : "red";
    ctx.fillRect(b.x, b.y, b.width, b.height);
  });
}

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // âœ… ë‚œì´ë„ ë©”ë‰´ ì¤‘ì¼ ë•Œ í´ë¦­ ì²˜ë¦¬
  if (difficultyMenuActive) {
    // ë‚œì´ë„ ë°•ìŠ¤ í´ë¦­
    for (let i = 0; i < difficultyOptions.length; i++) {
      const y = 230 + i * 60;
      if (mouseX >= 150 && mouseX <= 350 && mouseY >= y && mouseY <= y + 40) {
        selectedDifficultyIndex = i;
      }
    }

    // ì–¸ì–´ ì „í™˜ ë²„íŠ¼ í´ë¦­
    if (
      mouseX >= canvas.width - 90 &&
      mouseX <= canvas.width - 20 &&
      mouseY >= canvas.height - 50 &&
      mouseY <= canvas.height - 20
    ) {
      language = language === "ko" ? "en" : "ko";
    }

    return;
  }

  // âœ… ë„ì›€ë§ í† ê¸€ í´ë¦­ (ì „íˆ¬ í™”ë©´ UI)
  if (
    mouseX >= 10 &&
    mouseX <= 190 &&
    mouseY >= canvas.height - 60 &&
    mouseY <= canvas.height - 20
  ) {
    showHelp = !showHelp;
  }

  // âœ… ì–¸ì–´ ì „í™˜ ë²„íŠ¼ í´ë¦­ (ì „íˆ¬ ì¤‘ UI)
  if (
    mouseX >= canvas.width - 80 &&
    mouseX <= canvas.width - 10 &&
    mouseY >= canvas.height - 40 &&
    mouseY <= canvas.height - 10
  ) {
    language = language === "ko" ? "en" : "ko";
  }
});

function drawUI() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ì „íˆ¬ ë°•ìŠ¤ ì‹œê°í™”
  ctx.strokeStyle = "white";
  ctx.strokeRect(fightBox.x, fightBox.y, fightBox.width, fightBox.height);

  // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // ì  ì •ë³´ ë° ì²´ë ¥
  ctx.font = "20px Arial";
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.fillText(language === "ko" ? enemy.nameKo : enemy.nameEn, canvas.width / 2, 30);

  drawEnemyImage();
  drawHealthBar(canvas.width / 2 - 75, 40, 150, 15, enemy.hp, enemy.maxHp, "red");

  // í”Œë ˆì´ì–´ ì²´ë ¥ ë°” ë° UI
  drawHealthBar(20, 520, 150, 15, player.hp, player.maxHp, "lime");
  ctx.font = "16px Arial";
  ctx.fillStyle = "white";
  ctx.textAlign = "left";
 
  // ë³´ìœ  ê³¨ë“œ: ì²´ë ¥ë°” ìœ„ë¡œ ì´ë™
  ctx.font = "14px Arial";
  ctx.fillText("ğŸ§ª ì•„ì´í…œ: " + player.items, 20, 470);  // â† ì•„ì´í…œ ìˆ˜ ë¨¼ì € í‘œì‹œ
  ctx.fillText("ğŸª™ " + coins + "g", 20, 485);            // â† ê¸°ì¡´ ì½”ì¸ í‘œì‹œ


  // ê²Œì„ì˜¤ë²„ í‘œì‹œ
  if (gameOver) {
    ctx.fillStyle = gameWon ? "lime" : "red";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText(text[gameWon ? "victory" : "gameOver"][language], canvas.width / 2, canvas.height / 2);
    ctx.font = "20px Arial";
    ctx.fillText(text.restartPrompt[language], canvas.width / 2, canvas.height / 2 + 40);
  }

  // ê³ ë¸”ë¦° ìƒì  UI
  
  // ê³ ë¸”ë¦° ìƒì  UI
  if (isInShop) {
    ctx.fillStyle = "black";
    ctx.fillRect(50, 250, 400, 130);
    ctx.strokeStyle = "white";
    ctx.strokeRect(50, 250, 400, 130);
    ctx.fillStyle = "white";
    ctx.font = "16px Arial";
    ctx.textAlign = "left";
    ctx.fillText(text.shopTitle[language], 60, 270);
    const shopItems = text.shopItems[language];
    ctx.fillText("Z: " + shopItems[1], 60, 300); // ë¬´ê¸°
    ctx.fillText("X: " + shopItems[0], 60, 330); // ì•„ì´í…œ
    ctx.fillText(text.shopInstruction[language], 60, 360);
  }


  drawHelpUI();
  drawRobotWarnings();
}

function drawEnemyImage() {
  if (!enemy || !enemy.img) return;
  const img = enemy.img;
  if (img.complete) {
    const sway = Math.sin(tick / 20) * 5;
    const scale = enemy.scale || 1;
    const width = 64 * scale;
    const height = 64 * scale;
    ctx.drawImage(
      img,
      canvas.width / 2 - width / 2 + sway,
      70 - (scale - 1) * 32,
      width,
      height
    );
  }
}

function drawHelpUI() {
  ctx.fillStyle = "black";
  ctx.fillRect(10, canvas.height - 60, 180, showHelp ? 100 : 40);
  ctx.fillStyle = "white";
  ctx.font = "14px Arial";
  ctx.fillText(text.helpToggle[language], 20, canvas.height - 40);
  if (showHelp) {
    text.helpLines[language].forEach((line, i) => {
      ctx.fillText(line, 20, canvas.height - 25 + i * 15);
    });
  }
  ctx.fillStyle = "black";
  ctx.fillRect(canvas.width - 80, canvas.height - 40, 70, 30);
  ctx.fillStyle = "white";
  ctx.fillText(text.langLabel[language], canvas.width - 70, canvas.height - 20);
}

function updatePlayerMovement() {
  if (gameOver || isInShop) return;

  if ((keys["ArrowLeft"] || keys["a"]) && player.x > fightBox.x)
    player.x -= player.speed;
  if ((keys["ArrowRight"] || keys["d"]) && player.x + player.width < fightBox.x + fightBox.width)
    player.x += player.speed;
  if ((keys["ArrowUp"] || keys["w"]) && player.y > fightBox.y)
    player.y -= player.speed;
  if ((keys["ArrowDown"] || keys["s"]) && player.y + player.height < fightBox.y + fightBox.height)
    player.y += player.speed;
}
document.addEventListener("keydown", (e) => {
  const preventList = ["z", "x", "c", " ", "p", "o", "Enter"];
  if (preventList.includes(e.key)) e.preventDefault();

  keys[e.key] = true;

  // ë‚œì´ë„ ì„ íƒ ë©”ë‰´ ì¡°ì‘
  if (difficultyMenuActive) {
    if (["ArrowUp", "w"].includes(e.key)) {
      selectedDifficultyIndex = (selectedDifficultyIndex + 2) % 3;
    }
    if (["ArrowDown", "s"].includes(e.key)) {
      selectedDifficultyIndex = (selectedDifficultyIndex + 1) % 3;
    }
    if (e.key === "Enter") {
      difficulty = difficultyOptions[selectedDifficultyIndex];
      difficultyMenuActive = false;
      enemy = enemies[currentEnemyIndex];
      applyDifficultyStats(enemy);
      resetPlayerStats();
      startGameLoop();
    }
    if (e.key.toLowerCase() === "z") {
      language = language === "ko" ? "en" : "ko";
    }
    return;
  }

  // ìˆ˜ë™ ì  ë³€ê²½ (P)
  if (e.key.toLowerCase() === "p" && !isInShop && !gameOver) {
    const input = prompt("Enter enemy index (0 ~ " + (enemies.length - 1) + "):");
    const index = parseInt(input);
    if (!isNaN(index) && index >= 0 && index < enemies.length) {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      currentEnemyIndex = index;
      enemy = enemies[currentEnemyIndex];
      applyDifficultyStats(enemy);
      resetPlayerStats();
      bullets.length = 0;
      gameOver = false;
      gameWon = false;
      turn = "player";
      isAttackGaugeActive = false;
      gaugeX = 0;
      tick = 0;
      robotWarnings = [];
      robotWarnTimer = 0;
      isInShop = (enemy.nameKo === "ê³ ë¸”ë¦° ìƒì ");
      startGameLoop();
    }
    return;
  }

  // ê²Œì„ ì¬ì‹œì‘ (ìŠ¤í˜ì´ìŠ¤)
  if (gameOver && e.key === " ") {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    currentEnemyIndex = 0;
    enemy = enemies[currentEnemyIndex];
    applyDifficultyStats(enemy);
    resetPlayerStats();
    player.items = 10;
    coins = 0;
    playerAttackPower = 1;
    gameOver = false;
    gameWon = false;
    bullets.length = 0;
    turn = "player";
    isAttackGaugeActive = false;
    gaugeX = 0;
    tick = 0;
    robotWarnings = [];
    robotWarnTimer = 0;
    isInShop = false;
    startGameLoop();
    return;
  }

  // ìƒì  ì¡°ì‘
  if (isInShop) {
    if (e.key === "z" && coins >= 5) {
      coins -= 5;
      playerAttackPower++;
    } else if (e.key === "x" && coins >= 5) {
      coins -= 5;
      player.items++;
    } else if (e.key === "c") {
      isInShop = false;
      currentEnemyIndex++;
      if (currentEnemyIndex >= enemies.length) {
        gameOver = true;
        gameWon = true;
        return;
      }
      enemy = enemies[currentEnemyIndex];
      applyDifficultyStats(enemy);
      resetPlayerStats();
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    }
    return;
  }

  // ë””ë²„ê·¸ìš© ì½”ì¸ ì¦ê°€ (Oí‚¤ â†’ ë¹„ë°€ë²ˆí˜¸ ì¸ì¦)
  if (e.key.toLowerCase() === "o") {
    if (!cheatUnlocked) {
      const input = prompt("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
      if (input === "1211") {
        cheatUnlocked = true;
        alert("ë””ë²„ê·¸ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
      } else {
        alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.");
        return;
      }
    }
    coins++;
    return;
  }


  // ê³µê²© ê²Œì´ì§€ íƒ€ì´ë° ì…ë ¥
  if (isAttackGaugeActive && [" ", "Enter", "z"].includes(e.key)) {
    evaluateAttack();
    return;
  }

  // í”Œë ˆì´ì–´ í„´ ì¡°ì‘
  if (turn === "player" && !gameOver && !isAttackGaugeActive) {
    if (e.key === "z") {
      isAttackGaugeActive = true;
      gaugeX = 0;
    } else if (e.key === "x" && player.items > 0) {
      player.items--;
      player.hp = Math.min(player.hp + Math.floor(player.maxHp / 4), player.maxHp);
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    } else if (e.key === "c") {
      player.hp -= Math.floor(player.maxHp / 4);
      enemy.hp -= Math.floor(enemy.maxHp / 3);
      if (enemy.hp <= 0) {
        coins += enemy.coin || 0;
        currentEnemyIndex++;
        if (currentEnemyIndex >= enemies.length) {
          gameOver = true;
          gameWon = true;
          return;
        } else {
          enemy = enemies[currentEnemyIndex];
          applyDifficultyStats(enemy);
          resetPlayerStats();
          isInShop = (enemy.nameKo === "ê³ ë¸”ë¦° ìƒì ");
        }
      }
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    }
  }
});

let debugAllowed = sessionStorage.getItem("debugMode") === "true";

// O í‚¤: ì¸ì¦ ë˜ëŠ” ì½”ì¸ ì¦ê°€
document.addEventListener("keydown", (e) => {
  const key = e.key.toLowerCase();

  if (key === "o") {
    if (!debugAllowed) {
      const pass = prompt("ë””ë²„ê·¸ ëª¨ë“œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
      if (pass === "1211") {
        debugAllowed = true;
        sessionStorage.setItem("debugMode", "true");
        alert("ë””ë²„ê·¸ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
      } else {
        alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.");
      }
    } else {
      coins++;
    }
    e.preventDefault();
    return;
  }

  // ê°œë°œì ë„êµ¬ ì°¨ë‹¨
  if (!debugAllowed) {
    const blocked = (
      e.key === "F12" ||
      (e.ctrlKey && e.shiftKey && ["I", "i", "J", "j", "C", "c"].includes(e.key)) ||
      (e.ctrlKey && e.key === "U")
    );
    if (blocked) {
      e.preventDefault();
      alert("ê°œë°œì ë„êµ¬ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }
  }
});

// í‚¤ í•´ì œ ì²˜ë¦¬
document.addEventListener("keyup", (e) => {
  keys[e.key] = false;
});

// ì°½ í¬ê¸°ë¡œ ê°œë°œì ë„êµ¬ ê°ì§€
let lastHeight = window.outerHeight;
setInterval(() => {
  if (!debugAllowed && window.outerHeight < lastHeight - 100) {
    alert("ê°œë°œì ë„êµ¬ ì‚¬ìš©ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.");
  }
  lastHeight = window.outerHeight;
}, 1000);


</script>
</body>
</html>
