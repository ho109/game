<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>턴제전투 게임?(커스텀)</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; color: white; }
    canvas { display: block; margin: 0 auto; background: #222; border: 3px solid white; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="550"></canvas>
<script>
  // ✅ 캔버스 및 게임 초기 설정
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const fightBox = { x: 50, y: 180, width: 400, height: 200 };
const player = {
  x: 240, y: 340, width: 20, height: 20, speed: 4,
  hp: 35, maxHp: 35, color: "lime", items: 0
};

const text = {
  helpToggle: {
    ko: "❓ 도움말 보기 (Z / X / C)",
    en: "❓ Show Help (Z / X / C)"
  },
  helpLines: {
    ko: ["- Z: 공격 게이지 시작", "- X: 아이템 사용", "- C: 필살기 / 상점 나가기"],
    en: ["- Z: Start Attack Gauge", "- X: Use Item", "- C: Special / Exit Shop"]
  },
  restartPrompt: {
    ko: "스페이스바를 눌러 다시 시작",
    en: "Press Space to Restart"
  },
  victory: {
    ko: "Victory!",
    en: "Victory!"
  },
  gameOver: {
    ko: "Game Over",
    en: "Game Over"
  },
  shopTitle: {
    ko: "고블린 상점 🪙",
    en: "Goblin Shop 🪙"
  },
  shopItems: {
    ko: ["아이템 (10g)", "무기   (10g)"],
    en: ["Item (10g)", "Weapon (10g)"]
  },
  shopInstruction: {
    ko: "Z: 구매 | C: 나가기",
    en: "Z: Buy | C: Exit"
  },
  shopCoins: {
    ko: "보유 코인: ",
    en: "Coins: "
  },
  itemsLabel: {
    ko: "아이템: ",
    en: "Items: "
  },
  langLabel: {
    ko: "🇰🇷 한국어",
    en: "🇺🇸 English"
  }
}; // (기존 다국어 텍스트 객체 그대로 유지)

let coins = 0;
let currentEnemyIndex = 0;
let enemy = null;
let tick = 0;
const bullets = [];
let gameOver = false;
let gameWon = false;
let turn = "player";
let attackTimer = 0;
let attackDuration = 300;
let isAttackGaugeActive = false;
let gaugeX = 0;
let gaugeDir = 4;
let isGameRunning = false;
let keys = {};
let isInShop = false;
let shopSelection = 0;
let playerAttackPower = 1;
let robotWarnings = []; // 경고 타일들
let robotWarnTimer = 0;
let showHelp = false;
let language = "ko";
let animationFrameId = null; // 루프 추적용
let screenShake = 0;
let flashTimer = 0;

const imagePaths = [
  "image/slime.png",
  "image/bat.png",
  "image/skel.png",
  "image/skull.png",
  "image/king_slime.png",
  "image/robot.png",
  "image/weezered.png",
  "image/real_wizard.png",
  "image/gob_shop.png",
  "image/fire.png"
];

const enemies = [
  { name: "슬라임", maxHp: 10, hp: 10, atk: 1, pattern: () => spawnSlimeCornerSplits(), coin: 1, img: Object.assign(new Image(), { src: 'image/slime.png' }) },
  { name: "박쥐", maxHp: 12, hp: 12, atk: 2, pattern: () => spawnSideBullets(3), coin: 3, img: Object.assign(new Image(), { src: 'image/bat.png' }) },
  { name: "해골 궁수", maxHp: 15, hp: 15, atk: 3, pattern: () => spawnDiagonalBulletsFromTopRight(), coin: 5, img: Object.assign(new Image(), { src: 'image/skel.png' }) },
  { name: "해골 머리", maxHp: 18, hp: 18, atk: 3, pattern: () => spawnRandomBullets(6), coin: 7, img: Object.assign(new Image(), { src: 'image/skull.png' }) },
  { name: "거대 슬라임", maxHp: 80, hp: 80, atk: 2, pattern: () => spawnBouncingBullets(), coin: 15, img: Object.assign(new Image(), { src: 'image/king_slime.png' }), scale: 2 },
  { name: "로봇", maxHp: 30, hp: 30, atk: 3, pattern: () => spawnModifiedRobotBullets(), coin: 9, img: Object.assign(new Image(), { src: 'image/robot.png' }) },
  { name: "마법사..?", maxHp: 25, hp: 25, atk: 2, pattern: () => spawnSpiralBullets(), coin: 0, img: Object.assign(new Image(), { src: 'image/weezered.png' }) },
  { name: "진짜 마법사", maxHp: 40, hp: 40, atk: 3, pattern: () => realWizardPattern(), coin: 30, img: Object.assign(new Image(), { src: 'image/real_wizard.png' }) },
  { name: "고블린 상점", maxHp: 9999, hp: 9999, atk: 0, pattern: () => {}, coin: 0, img: Object.assign(new Image(), { src: 'image/gob_shop.png' }) },
  { name: "불", maxHp: 35, hp: 35, atk: 5, pattern: () => spawnRisingBullets(), coin: 20, img: Object.assign(new Image(), { src: 'image/fire.png' }) }
];

imagePaths.forEach((path, index) => {
  const img = new Image();
  img.src = path;
  img.onload = () => {
    enemies[index].img = img;
    if (index === imagePaths.length - 1) {
      enemy = enemies[currentEnemyIndex];
      if (!isGameRunning) {            // ✅ 반드시 중복 방지
        startGameLoop();
      }
    }
  };
});

function detectCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}
function drawAttackGauge() {
  if (!isAttackGaugeActive) return;
  const barX = canvas.width / 2 - 150;
  const barY = 470;
  ctx.fillStyle = "white";
  ctx.fillRect(barX, barY, 300, 20);
  ctx.fillStyle = "gray";
  ctx.fillRect(barX + 145, barY, 10, 20); // 중앙 노란 목표 지점
  ctx.fillStyle = "red";
  ctx.fillRect(barX + gaugeX, barY, 10, 20); // 움직이는 게이지 바
  gaugeX += gaugeDir;
  if (gaugeX <= 0 || gaugeX >= 290) gaugeDir *= -1;
}


function drawHealthBar(x, y, width, height, current, max, color) {
  ctx.fillStyle = "gray";
  ctx.fillRect(x, y, width, height);
  const ratio = Math.max(0, current / max);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, width * ratio, height);
}

function startGameLoop() {
  if (animationFrameId !== null) return; // 이미 실행 중이면 무시
  isGameRunning = true;
  animationFrameId = requestAnimationFrame(update);
}

function update() {
  if (!isGameRunning) return;
  tick++;

  // 💥 플래시 이펙트
  if (flashTimer > 0) {
    canvas.style.backgroundColor = (flashTimer % 2 === 0) ? "darkred" : "black";
    flashTimer--;
  } else {
    canvas.style.backgroundColor = "black";
  }

  // 💥 화면 흔들림 적용
  if (screenShake > 0) {
    const dx = (Math.random() - 0.5) * 10;
    const dy = (Math.random() - 0.5) * 10;
    ctx.save();
    ctx.translate(dx, dy);
    screenShake--;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawUI();
  drawAttackGauge();
  drawBullets();
  updatePlayerMovement();

  // ✅ 로봇 경고 후 폭발형 탄막
  if (robotWarnings.length > 0) {
    robotWarnTimer--;
    if (robotWarnTimer <= 0) {
      robotWarnings.forEach(pos => {
        const cx = pos.x;
        const cy = pos.y;
        const count = 12;
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count;
          bullets.push({
            x: cx,
            y: cy,
            width: 10,
            height: 10,
            speedX: Math.cos(angle) * 2.5,
            speedY: Math.sin(angle) * 2.5
          });
        }
      });
      screenShake = 6;
      flashTimer = 10;
      robotWarnings = [];
    }
  }

  if (!gameOver && turn === "enemy") {
    enemy.pattern();
    updateBullets();
    attackTimer--;
    if (attackTimer <= 0) {
      turn = "player";
      bullets.length = 0;
    }
  }

  // 💥 흔들림 해제
  if (screenShake > 0) {
    ctx.restore();
  }

  animationFrameId = requestAnimationFrame(update);
}

function spawnDiagonalBulletsFromTopRight() {
  if (tick % 25 !== 0) return; // 속도 프레임 높이기
  const count = 5; // 줄어든 밀도
  for (let i = 0; i < count; i++) {
    const startX = fightBox.x + fightBox.width;
    const startY = fightBox.y;
    const playerCenterX = player.x + player.width / 2;
    const playerCenterY = player.y + player.height / 2;
    const dx = playerCenterX - startX;
    const dy = playerCenterY - startY;
    const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.25; // 소폭 분산
    const speed = 4 + Math.random() * 1.5; // 더 빠르게
    const velocityX = Math.cos(angle) * speed;
    const velocityY = Math.sin(angle) * speed;

    bullets.push({
      x: startX,
      y: startY,
      width: 10,
      height: 10,
      speedX: velocityX,
      speedY: velocityY
    });
  }
}           

function spawnModifiedRobotBullets() {
  if (tick % 90 !== 0 || robotWarnings.length > 0) return;

  robotWarnings = [];
  robotWarnTimer = 50 //

  for (let i = 0; i < 6; i++) { // ✅ 경고 지점 6개
    const x = fightBox.x + Math.random() * fightBox.width;
    const y = fightBox.y + Math.random() * fightBox.height;
    robotWarnings.push({ x, y });
  }
}


function spawnSpiralBullets() {
  if (tick % 30 !== 0) return;
  const angleCount = 12;
  const centerX = fightBox.x + fightBox.width / 2;
  const centerY = fightBox.y + fightBox.height / 2;
  for (let i = 0; i < angleCount; i++) {
    const angle = (tick / 10) + (i * (Math.PI * 2 / angleCount));
    bullets.push({
      x: centerX,
      y: centerY,
      width: 8,
      height: 8,
      speedX: Math.cos(angle) * 2,
      speedY: Math.sin(angle) * 2
    });
  }
}
function realWizardPattern() {
  if (enemy.patternIndex === undefined) enemy.patternIndex = 0;
  if (enemy.patternTimer === undefined) enemy.patternTimer = 0;

  const stage = enemy.patternIndex;
  const timer = enemy.patternTimer;

  if (timer === 0) bullets.length = 0;

  if (stage === 0) spawnMeteorExplosions();
  if (stage === 1) spawnHomingShotsTeleport();
  if (stage === 2) spawnInwardSpiral();
  if (stage === 3) spawnDelayedBlastCross();

  enemy.patternTimer++;

  if (enemy.patternTimer > 300) {
    enemy.patternIndex++;
    enemy.patternTimer = 0;

    if (enemy.patternIndex > 3) {
      enemy.patternIndex = 0;
      if (enemy.hp > 0) {
        enemy.hp = Math.min(enemy.maxHp, enemy.hp + Math.floor(enemy.maxHp / 3));
        flashTimer = 15;
        screenShake = 8;
      }
    }
  }
}

function spawnMeteorExplosions() {
  if (tick % 45 === 0) {
    const meteor = {
      x: fightBox.x + Math.random() * (fightBox.width - 30),
      y: fightBox.y - 30,
      width: 30,
      height: 30,
      speedY: 2.5,
      starburst: true,
      timer: 40,
      blink: 0
    };
    bullets.push(meteor);
  }
}

function spawnHomingShotsTeleport() {
  if (tick % 60 !== 0) return;

  const burstCount = 3; // 동시 발사 수
  for (let i = 0; i < burstCount; i++) {
    const fromX = fightBox.x + Math.random() * fightBox.width;
    const fromY = fightBox.y + Math.random() * fightBox.height;

    const dx = (player.x + player.width / 2) - fromX;
    const dy = (player.y + player.height / 2) - fromY;
    const angle = Math.atan2(dy, dx);
    const speed = 2 + Math.random() * 1.5;

    bullets.push({
      x: fromX,
      y: fromY,
      width: 10,
      height: 10,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed
    });
  }

  screenShake = 2;
  flashTimer = 4;
}


function spawnInwardSpiral() {
  if (tick % 10 !== 0) return;

  const centerX = fightBox.x + fightBox.width / 2;
  const centerY = fightBox.y + fightBox.height / 2;

  const radius = 200;
  const count = 12;

  for (let i = 0; i < count; i++) {
    const angle = (tick / 20) + (Math.PI * 2 * i / count);
    bullets.push({
      x: centerX + Math.cos(angle) * radius,
      y: centerY + Math.sin(angle) * radius,
      width: 6,
      height: 6,
      speedX: -Math.cos(angle) * 1.5,
      speedY: -Math.sin(angle) * 1.5
    });
  }
}

function spawnDelayedBlastCross() {
  if (tick % 80 !== 0) return;

  const dropCount = 5;
  for (let i = 0; i < dropCount; i++) {
    const offsetX = Math.random() * fightBox.width;
    const startX = fightBox.x + offsetX;
    const startY = fightBox.y - 20 - Math.random() * 40; // 위쪽 + 약간 위에서 시작
    const delay = 50 + Math.random() * 30; // 각자 폭발 딜레이 다름

    bullets.push({
      x: startX,
      y: startY,
      width: 14,
      height: 14,
      speedY: 1.8,
      delayBlast: true,
      timer: delay,
      blink: 0
    });
  }
}


function spawnSideBullets(count = 2) {
  if (tick % 15 !== 0) return; // 발사 시간 조정정
  for (let i = 0; i < count; i++) {
    bullets.push({
      x: i % 2 === 0 ? fightBox.x : fightBox.x + fightBox.width,
      y: fightBox.y + Math.random() * fightBox.height,
      width: 10,
      height: 10,
      speedX: i % 2 === 0 ? 2 : -2,
      horizontal: true
    });
  }
}

function spawnRandomBullets(count = 4) {
  if (tick % 24 !== 0) return; // 약 0.4초 간격
  for (let i = 0; i < count; i++) {
    let x = fightBox.x + Math.random() * fightBox.width;
    x += (Math.random() - 0.5) * 60; // 좌우 ±30px 퍼짐
    x = Math.max(fightBox.x, Math.min(fightBox.x + fightBox.width - 10, x)); // 경계 제한

    bullets.push({
      x,
      y: fightBox.y,
      width: 10,
      height: 10,
      speedY: 2.5 + Math.random() * 1.5
    });
  }
}

function spawnBouncingBullets() {
  if (tick % 30 !== 0) return;
  const count = 10; // 10
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1.2 + Math.random() * 0.8; // 살짝 느리게 조정
    bullets.push({
      x: fightBox.x + fightBox.width / 2 + (Math.random() * 40 - 20),
      y: fightBox.y + fightBox.height / 2 + (Math.random() * 40 - 20),
      width: 6,
      height: 6,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed,
      bounce: true,
      bouncesLeft: 2 // 튕김 횟수도 3 → 2 로 낮출 수 있음
    });
  }
}

function spawnRisingBullets() {
  if (tick % 20 !== 0) return;

  const spawnCount = Math.random() < 0.5 ? 1 : 2;
  for (let i = 0; i < spawnCount; i++) {
    bullets.push({
      x: fightBox.x + Math.random() * fightBox.width,
      y: fightBox.y + fightBox.height + Math.random() * 20,
      width: 10,
      height: 10,
      speedY: -1.43, // 🔼 10% 상승
      fireExplode: true,
      flicker: true,
      baseX: Math.random() * Math.PI * 2
    });
  }
}

function spawnSlimeCornerSplits() {
  if (tick % 60 !== 0) return;
  const corners = [
    { x: fightBox.x, y: fightBox.y },
    { x: fightBox.x + fightBox.width, y: fightBox.y },
    { x: fightBox.x, y: fightBox.y + fightBox.height },
    { x: fightBox.x + fightBox.width, y: fightBox.y + fightBox.height },
  ];
  corners.forEach(corner => {
    bullets.push({
      x: corner.x,
      y: corner.y,
      width: 12,
      height: 12,
      speedX: (player.x - corner.x) / 60,
      speedY: (player.y - corner.y) / 60
    });
  });
}

function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];

    // 기본 이동
    if (b.speedX) b.x += b.speedX;
    if (b.speedY) b.y += b.speedY;

    // 일렁임 효과 (불꽃)
    if (b.flicker) {
      b.x += Math.sin(tick / 5 + (b.baseY || b.baseX || 0)) * 0.5;
    }

    // 🔥 불 패턴 폭발
    if (b.fireExplode && b.y + b.height <= fightBox.y) {
      explodeFireBullet(b);
      bullets.splice(i, 1);
      continue;
    }

    // ☄️ 유성 폭발형
    if (b.starburst) {
      b.timer--;
      b.blink = (b.blink + 1) % 20;
      if (b.timer <= 0) {
        const cx = b.x + b.width / 2;
        const cy = b.y + b.height / 2;
        for (let j = 0; j < 12; j++) {
          const angle = (Math.PI * 2 * j) / 12;
          bullets.push({
            x: cx,
            y: cy,
            width: 8,
            height: 8,
            speedX: Math.cos(angle) * 2,
            speedY: Math.sin(angle) * 2
          });
        }
        screenShake = 5;
        flashTimer = 10;
        bullets.splice(i, 1);
        continue;
      }
    }

    // 💣 지연 폭발형 (십자탄)
    if (b.delayBlast) {
      b.timer--;
      b.blink = (b.blink + 1) % 20;
      if (b.timer <= 0) {
        const cx = b.x + b.width / 2;
        const cy = b.y + b.height / 2;
        const spread = [
          { dx: 0, dy: -3 },
          { dx: 0, dy: 3 },
          { dx: -3, dy: 0 },
          { dx: 3, dy: 0 }
        ];
        for (const dir of spread) {
          bullets.push({
            x: cx,
            y: cy,
            width: 8,
            height: 8,
            speedX: dir.dx,
            speedY: dir.dy
          });
        }
        screenShake = 4;
        flashTimer = 8;
        bullets.splice(i, 1);
        continue;
      }
    }

    // 💥 플레이어 피격
    if (!b.starburst && !b.delayBlast && detectCollision(player, b)) {
      b.y = -100;
      player.hp -= enemy.atk;
      if (player.hp <= 0) {
        gameOver = true;
        gameWon = false;
      }
    }
  }
}


function explodeFireBullet(bullet) {
  const centerX = bullet.x + bullet.width / 2;
  const centerY = bullet.y + bullet.height / 2;
  const angleCount = 7;
  for (let i = 0; i < angleCount; i++) {
    const angle = (Math.PI * 2 / angleCount) * i;
    const speed = 2 + Math.random() * 0.5;
    bullets.push({
      x: centerX,
      y: centerY,
      width: 8,
      height: 8,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed
    });
  }
  flashTimer = 5;
  screenShake = 2;
}

function evaluateAttack() {
  const center = 150;
  const dist = Math.abs(gaugeX - center);
  let damage = 1;
  if (dist < 10) damage = 5;
  else if (dist < 30) damage = 3;
  else if (dist < 60) damage = 2;

  enemy.hp -= damage * playerAttackPower;
  if (enemy.hp <= 0) {
    coins += enemy.coin || 0;
    currentEnemyIndex++;
    if (currentEnemyIndex >= enemies.length) {
      gameOver = true;
      gameWon = true;
      return;
    } else {
      enemy = enemies[currentEnemyIndex];
      enemy.hp = enemy.maxHp;
      player.hp = player.maxHp;
      if (enemy.name === "고블린 상점") {
        isInShop = true;
      }
    }
  }
  isAttackGaugeActive = false;
  turn = "enemy";
  attackTimer = attackDuration;
  bullets.length = 0;
}
    
function drawRobotWarnings() {
  ctx.fillStyle = "rgba(255, 100, 100, 0.5)"; // 연한 빨강 (50% 투명도)
  robotWarnings.forEach(pos => {
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawBullets() {
  bullets.forEach(b => {
    if (b.starburst && b.blink < 10) return; // 깜빡일 때 안 그림
    ctx.fillStyle = b.starburst ? "yellow" : "red";
    ctx.fillRect(b.x, b.y, b.width, b.height);
  });
}

// ✅ 전투 박스 및 플레이어 표시, 도움말 클릭 및 언어 전환 기능 추가
canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // 도움말 버튼 영역 클릭
  if (mouseX >= 10 && mouseX <= 190 && mouseY >= canvas.height - 60 && mouseY <= canvas.height - 20) {
    showHelp = !showHelp;
  }

  // 언어 변경 버튼 클릭
  if (mouseX >= canvas.width - 80 && mouseX <= canvas.width - 10 && mouseY >= canvas.height - 40 && mouseY <= canvas.height - 10) {
    language = language === "ko" ? "en" : "ko";
  }
});

function drawUI() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 전투 박스 시각화
  ctx.strokeStyle = "white";
  ctx.strokeRect(fightBox.x, fightBox.y, fightBox.width, fightBox.height);

  // 플레이어 그리기
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // 적 정보 및 체력
  ctx.font = "20px Arial";
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.fillText(enemy.name, canvas.width / 2, 30);
  drawEnemyImage();
  drawHealthBar(canvas.width / 2 - 75, 40, 150, 15, enemy.hp, enemy.maxHp, "red");

  // 플레이어 체력 바 및 UI
  drawHealthBar(20, 520, 150, 15, player.hp, player.maxHp, "lime");
  ctx.font = "16px Arial";
  ctx.textAlign = "left";
  ctx.fillText(text.itemsLabel[language] + player.items, 20, 505);

  // 보유 골드: 체력바 위로 이동
  ctx.font = "14px Arial";
  ctx.fillText("🪙 " + coins + "g", 20, 490);

  // 게임오버 표시
  if (gameOver) {
    ctx.fillStyle = gameWon ? "lime" : "red";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText(text[gameWon ? "victory" : "gameOver"][language], canvas.width / 2, canvas.height / 2);
    ctx.font = "20px Arial";
    ctx.fillText(text.restartPrompt[language], canvas.width / 2, canvas.height / 2 + 40);
  }

  // 고블린 상점 UI
  if (isInShop) {
    ctx.fillStyle = "black";
    ctx.fillRect(50, 250, 400, 130);
    ctx.strokeStyle = "white";
    ctx.strokeRect(50, 250, 400, 130);
    ctx.fillStyle = "white";
    ctx.font = "16px Arial";
    ctx.textAlign = "left";
    ctx.fillText("🛒 Goblin Shop", 60, 270);
    ctx.fillText("Z: 강화 (공격력 +1, 5g)", 60, 300);
    ctx.fillText("X: 아이템 구매 (5g)", 60, 330);
    ctx.fillText("C: 상점 종료", 60, 360);
  }

  drawHelpUI();
  drawRobotWarnings();
}

function drawEnemyImage() {
  if (!enemy || !enemy.img) return;
  const img = enemy.img;
  if (img.complete) {
    const sway = Math.sin(tick / 20) * 5;
    const scale = enemy.scale || 1;
    const width = 64 * scale;
    const height = 64 * scale;
    ctx.drawImage(
      img,
      canvas.width / 2 - width / 2 + sway,
      70 - (scale - 1) * 32,
      width,
      height
    );
  }
}

function drawHelpUI() {
  ctx.fillStyle = "black";
  ctx.fillRect(10, canvas.height - 60, 180, showHelp ? 100 : 40);
  ctx.fillStyle = "white";
  ctx.font = "14px Arial";
  ctx.fillText(text.helpToggle[language], 20, canvas.height - 40);
  if (showHelp) {
    text.helpLines[language].forEach((line, i) => {
      ctx.fillText(line, 20, canvas.height - 25 + i * 15);
    });
  }
  ctx.fillStyle = "black";
  ctx.fillRect(canvas.width - 80, canvas.height - 40, 70, 30);
  ctx.fillStyle = "white";
  ctx.fillText(text.langLabel[language], canvas.width - 70, canvas.height - 20);
}

function updatePlayerMovement() {
  if (gameOver || isInShop) return;

  if ((keys["ArrowLeft"] || keys["a"]) && player.x > fightBox.x)
    player.x -= player.speed;
  if ((keys["ArrowRight"] || keys["d"]) && player.x + player.width < fightBox.x + fightBox.width)
    player.x += player.speed;
  if ((keys["ArrowUp"] || keys["w"]) && player.y > fightBox.y)
    player.y -= player.speed;
  if ((keys["ArrowDown"] || keys["s"]) && player.y + player.height < fightBox.y + fightBox.height)
    player.y += player.speed;
}

document.addEventListener("keydown", (e) => {
  const preventList = ["z", "x", "c", " ", "p", "Enter"];
  if (preventList.includes(e.key)) e.preventDefault();

  keys[e.key] = true;

  // ✅ P 키: 수동 적 변경
  if (e.key.toLowerCase() === "p" && !isInShop && !gameOver) {
    const input = prompt("Enter enemy index (0 ~ " + (enemies.length - 1) + "):");
    const index = parseInt(input);
    if (!isNaN(index) && index >= 0 && index < enemies.length) {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }

      currentEnemyIndex = index;
      enemy = enemies[currentEnemyIndex];
      enemy.hp = enemy.maxHp;
      player.hp = player.maxHp;
      bullets.length = 0;
      gameOver = false;
      gameWon = false;
      turn = "player";
      isAttackGaugeActive = false;
      gaugeX = 0;
      tick = 0;
      robotWarnings = [];
      robotWarnTimer = 0;
      isInShop = (enemy.name === "고블린 상점");

      startGameLoop();
    }
    return;
  }

  // ✅ 게임 재시작
  if (gameOver && e.key === " ") {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }

    currentEnemyIndex = 0;
    enemy = enemies[currentEnemyIndex];
    player.hp = player.maxHp;
    player.items = 10;
    coins = 0;
    gameOver = false;
    gameWon = false;
    bullets.length = 0;
    turn = "player";
    isAttackGaugeActive = false;
    gaugeX = 0;
    tick = 0;
    robotWarnings = [];
    robotWarnTimer = 0;
    isInShop = false;

    startGameLoop();
    return;
  }

  // ✅ 상점 처리
  if (isInShop) {
    if (e.key === "z" && coins >= 5) {
      coins -= 5;
      playerAttackPower++;
    } else if (e.key === "x" && coins >= 5) {
      coins -= 5;
      player.items++;
    } else if (e.key === "c") {
      isInShop = false;
      currentEnemyIndex++;
      if (currentEnemyIndex >= enemies.length) {
        gameOver = true;
        gameWon = true;
        return;
      }
      enemy = enemies[currentEnemyIndex];
      enemy.hp = enemy.maxHp;
      player.hp = player.maxHp;
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    }
    return;
  }

  // ✅ 공격 평가
  if (isAttackGaugeActive && [" ", "Enter", "z"].includes(e.key)) {
    evaluateAttack();
    return;
  }

  // ✅ 플레이어 턴 중 조작
  if (turn === "player" && !gameOver && !isAttackGaugeActive) {
    if (e.key === "z") {
      isAttackGaugeActive = true;
      gaugeX = 0;
    } else if (e.key === "x" && player.items > 0) {
      player.items--;
      player.hp = Math.min(player.hp + Math.floor(player.maxHp / 4), player.maxHp);
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    } else if (e.key === "c") { // 🔧 FIXED: 정확한 위치
      player.hp -= Math.floor(player.maxHp / 4);
      enemy.hp -= Math.floor(enemy.maxHp / 3);
      if (enemy.hp <= 0) {
        currentEnemyIndex++;
        if (currentEnemyIndex >= enemies.length) {
          gameOver = true;
          gameWon = true;
          return;
        } else {
          enemy = enemies[currentEnemyIndex];
          enemy.hp = enemy.maxHp;
          player.hp = player.maxHp;
        }
      }
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    }
  }
});

document.addEventListener("keyup", (e) => keys[e.key] = false);

</script>
</body>
</html>
