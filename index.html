<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>턴제전투 게임?(커스텀)</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; color: white; }
    canvas { display: block; margin: 0 auto; background: #222; border: 3px solid white; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="550"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const fightBox = { x: 50, y: 180, width: 400, height: 200 };
const player = {
  x: 240, y: 340, width: 20, height: 20, speed: 4,
  hp: 20, maxHp: 20, color: "lime", items: 10
};

const imagePaths = [
  "images/slime.png", "images/bat.png", "images/skel.png", "images/gob.png",
  "images/wolf.png", "images/wizaed.png", "images/robot.png", "images/fireeee.png",
  "images/slime.png" // 거대 슬라임도 동일 이미지 사용
];

const enemies = [
  { name: "슬라임", maxHp: 5, hp: 5, atk: 1, pattern: () => spawnCenterBullet(), img: new Image(), frameCount: 1 },
  { name: "박쥐", maxHp: 12, hp: 12, atk: 1, pattern: () => spawnSideBullets(3), img: new Image(), frameCount: 1 },
  { name: "스켈레톤", maxHp: 15, hp: 15, atk: 2, pattern: () => spawnRandomBullets(6), img: new Image(), frameCount: 1 },
  { name: "고블린", maxHp: 18, hp: 18, atk: 3, pattern: () => spawnDiagonalBulletsFromTopRight(), img: new Image(), frameCount: 1 },
  { name: "늑대", maxHp: 20, hp: 20, atk: 4, pattern: () => spawnAlternatingTopBottomBullets(), img: new Image(), frameCount: 1 },
  { name: "마법사", maxHp: 25, hp: 25, atk: 3, pattern: () => spawnSpiralBullets(), img: new Image(), frameCount: 1 },
  { name: "로봇", maxHp: 30, hp: 30, atk: 4, pattern: () => spawnBigDirectionalSquares(), img: new Image(), frameCount: 1 },
  { name: "불", maxHp: 35, hp: 35, atk: 5, pattern: () => spawnRisingBullets(), img: new Image(), frameCount: 1 },
  { name: "거대 슬라임", maxHp: 80, hp: 80, atk: 0.5, pattern: () => spawnBouncingBullets(), img: new Image(), frameCount: 1, scale: 2 }
];

let imagesLoaded = 0;
imagePaths.forEach((path, index) => {
  const img = new Image();
  img.src = path;
  img.onload = () => {
    enemies[index].img = img;
    imagesLoaded++;
    if (imagesLoaded === imagePaths.length) {
  startGameLoop(); // ✅ 안전하게 루프 시작

    }
  };
});

function startGameLoop() {
  if (!isGameRunning) {
    isGameRunning = true;
    update();
  }
}

function drawEnemyImage() {
  const img = enemy.img;
  if (img && img.complete) {
    const sway = Math.sin(tick / 20) * 5;
    const scale = enemy.scale || 1; // 없으면 기본 1배
    const width = 64 * scale;
    const height = 64 * scale;
    ctx.drawImage(
      img,
      canvas.width / 2 - width / 2 + sway,
      70 - (scale - 1) * 32, // 아래로 내려가는 걸 방지
      width,
      height
    );
  }
}

function spawnCenterBullet() {
  bullets.push({
    x: fightBox.x + fightBox.width / 2 - 5,
    y: fightBox.y,
    width: 10,
    height: 10,
    speedY: 3
  });
}

function spawnSideBullets(count) {
  for (let i = 0; i < count; i++) {
    bullets.push({
      x: i % 2 === 0 ? fightBox.x : fightBox.x + fightBox.width,
      y: fightBox.y + Math.random() * fightBox.height,
      width: 10,
      height: 10,
      speedX: i % 2 === 0 ? 2 : -2,
      horizontal: true
    });
  }
}

function spawnRandomBullets(count) {
  for (let i = 0; i < count; i++) {
    bullets.push({
      x: fightBox.x + Math.random() * fightBox.width,
      y: fightBox.y,
      width: 10,
      height: 10,
      speedY: 2 + Math.random() * 2
    });
  }
}

function spawnDiagonalBulletsFromTopRight() {
  const count = 5; // 밀도
  for (let i = 0; i < count; i++) {
    const startX = fightBox.x + fightBox.width;
    const startY = fightBox.y;
    const playerCenterX = player.x + player.width / 2;
    const playerCenterY = player.y + player.height / 2;

    // 방향 벡터 계산
    let dx = playerCenterX - startX;
    let dy = playerCenterY - startY;
    const magnitude = Math.sqrt(dx * dx + dy * dy);

    // 퍼짐 적용 (각도에 약간의 무작위 오차 추가)
    const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.4; // ±0.2 라디안 정도 산포
    const speed = 2.5 + Math.random(); // 약간의 속도 변동
    const velocityX = Math.cos(angle) * speed;
    const velocityY = Math.sin(angle) * speed;

    bullets.push({
      x: startX,
      y: startY,
      width: 10,
      height: 10,
      speedX: velocityX,
      speedY: velocityY
    });
  }
}
function spawnAlternatingTopBottomBullets() {
  const isTop = tick % 60 < 30;
  const startY = isTop ? fightBox.y : fightBox.y + fightBox.height - 10;
  const dirY = isTop ? 1 : -1;

  const spacing = 100; // 탄 간격 유지
  const count = Math.floor(fightBox.width / spacing);

  // 전체 줄의 좌우 흔들림 (sine으로 부드럽게)
  const sway = Math.sin(tick / 30) * 40; // 좌우 최대 40px 흔들림

  for (let i = 0; i <= count; i++) {
    const baseX = fightBox.x + i * spacing + sway;
    bullets.push({
      x: baseX,
      y: startY,
      width: 10,
      height: 10,
      speedX: 0,
      speedY: dirY * 2
    });
  }
}



function spawnSpiralBullets() {
  const angleCount = 12;
  const centerX = fightBox.x + fightBox.width / 2;
  const centerY = fightBox.y + fightBox.height / 2;
  for (let i = 0; i < angleCount; i++) {
    const angle = (tick / 10) + (i * (Math.PI * 2 / angleCount));
    bullets.push({
      x: centerX,
      y: centerY,
      width: 8,
      height: 8,
      speedX: Math.cos(angle) * 2,
      speedY: Math.sin(angle) * 2
    });
  }
}

function spawnRisingBullets() {
  for (let i = 0; i < 1.5; i++) { // 밀도 1/4로 감소
    bullets.push({
      x: fightBox.x + Math.random() * fightBox.width,
      y: fightBox.y + fightBox.height,
      width: 10,
      height: 10,
      speedY: -2,
      fireExplode: true
    });
  }
}


function spawnBigDirectionalSquares() {
  const corner = robotCorners[robotCornerIndex % robotCorners.length];
  robotCornerIndex++;

  const dx = canvas.width / 2 - corner.x;
  const dy = fightBox.y + fightBox.height / 2 - corner.y;
  const mag = Math.sqrt(dx * dx + dy * dy);
  const speed = 3;

  bullets.push({
    x: corner.x,
    y: corner.y,
    width: 30,
    height: 30,
    speedX: dx / mag * speed,
    speedY: dy / mag * speed,
    robotExplode: true // 🚨 로봇 전용 속성
  });
}

function explodeFireBullet(bullet) {
  const centerX = bullet.x + bullet.width / 2;
  const centerY = bullet.y + bullet.height / 2;

  const angleCount = 6;
  for (let i = 0; i < angleCount; i++) {
    const angle = (Math.PI * 2 / angleCount) * i;
    const speed = 2 + Math.random() * 0.5;

    bullets.push({
      x: centerX,
      y: centerY,
      width: 8,
      height: 8,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed
    });
  }

  // 💥 효과 시작
  screenShake = 5;
  flashTimer = 5;
}

function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];

    if (b.speedX) b.x += b.speedX;
    if (b.speedY) b.y += b.speedY;

    // ✅ 벽 튕김 로직 + 반사 제한
    if (b.bounce) {
      let bounced = false;

      if (b.x <= fightBox.x || b.x + b.width >= fightBox.x + fightBox.width) {
        b.speedX *= -1;
        b.x = Math.max(fightBox.x, Math.min(b.x, fightBox.x + fightBox.width - b.width));
        bounced = true;
      }

      if (b.y <= fightBox.y || b.y + b.height >= fightBox.y + fightBox.height) {
        b.speedY *= -1;
        b.y = Math.max(fightBox.y, Math.min(b.y, fightBox.y + fightBox.height - b.height));
        bounced = true;
      }

      if (bounced) {
        b.bouncesLeft = (b.bouncesLeft || 5) - 1; // 기본값 5에서 1 감소
        if (b.bouncesLeft <= 0) {
          bullets.splice(i, 1);
          continue;
        }
      }
    }

    // 로봇 패턴
    if (b.robotExplode) {
      const hitWall =
        b.x <= fightBox.x || b.x + b.width >= fightBox.x + fightBox.width ||
        b.y <= fightBox.y || b.y + b.height >= fightBox.y + fightBox.height;

      if (hitWall) {
        explodeRobotBullet(b);
        bullets.splice(i, 1);
        continue;
      }
    }

    // 불꽃 패턴
    if (b.fireExplode && b.y + b.height <= fightBox.y) {
      explodeFireBullet(b);
      bullets.splice(i, 1);
      continue;
    }
  }
}



function spawnBouncingBullets() {
  const count = 10; // 줄임
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1.5 + Math.random(); // 느리게
    bullets.push({
      x: fightBox.x + fightBox.width / 2 + (Math.random() * 40 - 20),
      y: fightBox.y + fightBox.height / 2 + (Math.random() * 40 - 20),
      width: 6,
      height: 6,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed,
      bounce: true,
      bouncesLeft: 3 // ✅ 3번 튕기고 사라짐
    });
  }
}


function explodeRobotBullet(bullet) {
  const centerX = bullet.x + bullet.width / 2;
  const centerY = bullet.y + bullet.height / 2;

  const angleCount = 10;
  const spinMode = robotSpinPattern[robotSpinIndex % robotSpinPattern.length];
  robotSpinIndex++;

  for (let i = 0; i < angleCount; i++) {
    const baseAngle = (Math.PI * 2 / angleCount) * i;
    const actualAngle = spinMode === "cw" ? baseAngle : (Math.PI * 2 - baseAngle);
    
    // 🔥 속도: 1.2 ~ 1.5배 랜덤
    const speedMultiplier = 1.2 + Math.random() * 0.3;

    bullets.push({
      x: centerX,
      y: centerY,
      width: 8,
      height: 8,
      speedX: Math.cos(actualAngle) * 2 * speedMultiplier,
      speedY: Math.sin(actualAngle) * 2 * speedMultiplier
    });
  }
}





// 추가 변수 및 초기 상태
let screenShake = 0;
let flashTimer = 0;
let currentEnemyIndex = 0;
let enemy = enemies[currentEnemyIndex];
let tick = 0;
const bullets = [];
let keys = {};
let gameOver = false;
let gameWon = false;
let turn = "player";
let attackTimer = 0;
let attackDuration = 300;
let isAttackGaugeActive = false;
let gaugeX = 0;
let gaugeDir = 4;
let robotSpinIndex = 0;
const robotSpinPattern = ["cw", "ccw", "cw", "cw", "ccw", "ccw"];

let robotCornerIndex = 0;
const robotCorners = [
  { x: fightBox.x, y: fightBox.y },
  { x: fightBox.x + fightBox.width, y: fightBox.y },
  { x: fightBox.x + fightBox.width, y: fightBox.y + fightBox.height },
  { x: fightBox.x, y: fightBox.y + fightBox.height }
];

// 1. 중복 update() 방지용 상태 추가
let isGameRunning = false;
function update() {
  if (!isGameRunning) return;
  tick++;

  // 💥 깜빡임 배경
  if (flashTimer > 0) {
    canvas.style.backgroundColor = (flashTimer % 2 === 0) ? "darkred" : "black";
    flashTimer--;
  } else {
    canvas.style.backgroundColor = "black";
  }

  // 💥 흔들림 적용
  if (screenShake > 0) {
    const dx = (Math.random() - 0.5) * 10;
    const dy = (Math.random() - 0.5) * 10;
    ctx.save();
    ctx.translate(dx, dy);
    screenShake--;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawFightBox();
  movePlayer();
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.width, player.height);

  if (turn === "player") {
    if (isAttackGaugeActive) drawGaugeBar();
  } else if (turn === "enemy") {
    if (attackTimer % 30 === 0) enemy.pattern();
    updateBullets();
    drawBullets();
    handleCollisions();
    attackTimer--;
    if (attackTimer <= 0) {
      turn = "player";
      bullets.length = 0;
    }
  }

  drawUI();

  if (screenShake > 0) {
    ctx.restore(); // 흔들림 해제
  }

  if (gameOver) {
    isGameRunning = false;
    return;
  }

  requestAnimationFrame(update);
}

function drawFightBox() {
  ctx.strokeStyle = "white";
  ctx.strokeRect(fightBox.x, fightBox.y, fightBox.width, fightBox.height);
}

function movePlayer() {
  if (turn !== "enemy" || gameOver) return;
  if ((keys["ArrowLeft"] || keys["a"]) && player.x > fightBox.x) player.x -= player.speed;
  if ((keys["ArrowRight"] || keys["d"]) && player.x + player.width < fightBox.x + fightBox.width) player.x += player.speed;
  if ((keys["ArrowUp"] || keys["w"]) && player.y > fightBox.y) player.y -= player.speed;
  if ((keys["ArrowDown"] || keys["s"]) && player.y + player.height < fightBox.y + fightBox.height) player.y += player.speed;
}

function drawBullets() {
  ctx.fillStyle = "red";
  bullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));
}



function detectCollision(a, b) {
  return a.x < b.x + b.width &&
         a.x + a.width > b.x &&
         a.y < b.y + b.height &&
         a.y + a.height > b.y;
}

function handleCollisions() {
  bullets.forEach(b => {
    if (detectCollision(player, b)) {
      b.y = -100;
      player.hp -= enemy.atk;
      if (player.hp <= 0) gameOver = true;
    }
  });
}

function drawGaugeBar() {
  const barX = 100, barY = 300, barWidth = 300, barHeight = 20;
  ctx.fillStyle = "gray";
  ctx.fillRect(barX, barY, barWidth, barHeight);
  ctx.fillStyle = "white";
  ctx.fillRect(barX + barWidth / 2 - 2, barY, 4, barHeight);
  ctx.fillStyle = "yellow";
  ctx.fillRect(barX + gaugeX - 5, barY - 10, 10, barHeight + 20);
  gaugeX += gaugeDir;
  if (gaugeX <= 0 || gaugeX >= barWidth) gaugeDir *= -1;
}

function evaluateAttack() {
  const center = 150;
  const dist = Math.abs(gaugeX - center);
  let damage = 1;
  if (dist < 10) damage = 5;
  else if (dist < 30) damage = 3;
  else if (dist < 60) damage = 2;

  enemy.hp -= damage;
  if (enemy.hp <= 0) {
    currentEnemyIndex++;
    if (currentEnemyIndex >= enemies.length) {
      gameOver = true;
      gameWon = true;
      return;
    } else {
      enemy = enemies[currentEnemyIndex];
    enemy.hp = enemy.maxHp;
    player.hp = player.maxHp;
    bullets.length = 0;
    turn = "enemy";
    attackTimer = attackDuration;
    }
  }
  isAttackGaugeActive = false;
  turn = "enemy";
  attackTimer = attackDuration;
  bullets.length = 0;
}

function drawUI() {
  ctx.font = "20px Arial";
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.fillText(enemy.name, canvas.width / 2, 30);
  drawEnemyImage();
  drawHealthBar(canvas.width / 2 - 75, 40, 150, 15, enemy.hp, enemy.maxHp, "red");
  drawHealthBar(20, 520, 150, 15, player.hp, player.maxHp, "lime");
  ctx.font = "16px Arial";
  ctx.textAlign = "left";
  ctx.fillText("아이템: " + player.items, 20, 505);
  if (gameOver) {
    ctx.fillStyle = gameWon ? "lime" : "red";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText(gameWon ? "Victory!" : "Game Over", canvas.width / 2, canvas.height / 2);
    ctx.font = "20px Arial";
    ctx.fillText("스페이스바를 눌러 다시 시작", canvas.width / 2, canvas.height / 2 + 40);
  }
}

function drawHealthBar(x, y, width, height, current, max, color) {
  ctx.strokeStyle = "white";
  ctx.strokeRect(x, y, width, height);
  const ratio = Math.max(0, current / max);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, width * ratio, height);
}

document.addEventListener("keydown", (e) => {
  if (["z", "x", "c", " ", "p", "Enter", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "a", "s", "d", "w"].includes(e.key)) {
    e.preventDefault();
  }
  keys[e.key] = true;

  // 게임 재시작
  if (gameOver && e.key === " ") {
  currentEnemyIndex = 0;
  enemy = enemies[currentEnemyIndex];
  player.hp = player.maxHp;
  player.items = 10;
  gameOver = false;
  gameWon = false;
  bullets.length = 0;
  turn = "player";
  isAttackGaugeActive = false;
  gaugeX = 0;
  tick = 0;

  // ✅ 안전하게 루프 재시작
  isGameRunning = false;
  startGameLoop();
  return;
}


  // 공격 평가
  if (isAttackGaugeActive && (e.key === " " || e.key === "Enter" || e.key === "z")) {
    evaluateAttack();
  }
// 적 선택 기능 (P 키)
if (e.key.toLowerCase() === "p" && turn === "player" && !isAttackGaugeActive) {
  const input = prompt("Enter enemy index (0 ~ " + (enemies.length - 1) + "):");
  const index = parseInt(input);
  if (!isNaN(index) && index >= 0 && index < enemies.length) {
    currentEnemyIndex = index;
    enemy = enemies[index];
    enemy.hp = enemy.maxHp;
    player.hp = player.maxHp;
    bullets.length = 0;
    gameOver = false;
    gameWon = false;
    turn = "player";
    isAttackGaugeActive = false;
    gaugeX = 0;
    tick = 0;

    // ✅ 이 줄을 먼저 실행해야 중첩 방지됨
    if (!isGameRunning) {
      isGameRunning = true;
      update();
    }
  }
  return;
}


  // 기본 전투 조작 (Z/X/C)
  if (turn === "player" && !gameOver && !isAttackGaugeActive) {
    if (e.key === "z") {
      isAttackGaugeActive = true;
      gaugeX = 0;
    } else if (e.key === "x" && player.items > 0) {
      player.items--;
      player.hp = Math.min(player.hp + Math.floor(player.maxHp / 4), player.maxHp);
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    } else if (e.key === "c" && player.hp > Math.floor(player.maxHp / 4)) {
      player.hp -= Math.floor(player.maxHp / 4);
      enemy.hp -= Math.floor(enemy.maxHp / 3);
      if (enemy.hp <= 0) {
        currentEnemyIndex++;
        if (currentEnemyIndex >= enemies.length) {
          gameOver = true;
          gameWon = true;
          return;
        } else {
          enemy = enemies[currentEnemyIndex];
          enemy.hp = enemy.maxHp;
          player.hp = player.maxHp;
        }
      }
      turn = "enemy";
      attackTimer = attackDuration;
      bullets.length = 0;
    }
  }
});

document.addEventListener("keyup", (e) => keys[e.key] = false);
</script>
</body>
</html>
